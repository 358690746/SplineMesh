using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace SplineMesh {
    [ExecuteInEditMode]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineTiling : MonoBehaviour {
        private GameObject generated;
        private Spline spline = null;
        private bool toUpdate = false;

        public Mesh mesh;
        public Material material;
        public PhysicMaterial physicMaterial;
        public Vector3 translation;
        public Vector3 rotation;
        public Vector3 scale = Vector3.one;

        /// <summary>
        /// If true, the generated content will be updated in play mode.
        /// If false, the content generated and saved to the scene will be used in playmode without modification.
        /// Usefull to preserve lightmaps baked for static objects.
        /// </summary>
        public bool updateInPlayMode;

        public bool curveSpace = false;

        public MeshBender.FillingMode mode = MeshBender.FillingMode.StretchToInterval;

        private void OnEnable() {
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();

            toUpdate = true;
        }

        private void OnValidate() {
            if (spline == null) return;
            toUpdate = true;
        }

        private void Update() {
            // we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
            if (!updateInPlayMode && Application.isPlaying) return;

            if (toUpdate) {
                toUpdate = false;
                CreateMeshes();
            }
        }

        public void CreateMeshes() {
            List<GameObject> used = new List<GameObject>();

            if (curveSpace) {
                int i = 0;
                foreach(var curve in spline.curves) {
                    var childName = "segment " + i++ + " mesh";
                    var childTransform = generated.transform.Find(childName);
                    GameObject go;
                    if (childTransform == null) {
                        go = UOUtility.Create(childName,
                            generated,
                            typeof(MeshFilter),
                            typeof(MeshRenderer),
                            typeof(MeshBender),
                            typeof(MeshCollider));
                        go.isStatic = true;
                    } else {
                        go = childTransform.gameObject;
                    }
                    go.GetComponent<MeshRenderer>().material = material;
                    go.GetComponent<MeshCollider>().material = physicMaterial;
                    MeshBender mb = go.GetComponent<MeshBender>();
                    mb.Source = SourceMesh.Build(mesh)
                        .Translate(translation)
                        .Rotate(Quaternion.Euler(rotation))
                        .Scale(scale);
                    mb.SetInterval(curve);
                    mb.Mode = mode;
                    mb.ComputeIfNeeded();
                    used.Add(go);
                }
            } else {
                var childName = "segment 1 mesh";
                var childTransform = generated.transform.Find(childName);
                GameObject go;
                if (childTransform == null) {
                    go = UOUtility.Create(childName,
                        generated,
                        typeof(MeshFilter),
                        typeof(MeshRenderer),
                        typeof(MeshBender),
                        typeof(MeshCollider));
                    go.isStatic = true;
                } else {
                    go = childTransform.gameObject;
                }
                go.GetComponent<MeshRenderer>().material = material;
                go.GetComponent<MeshCollider>().material = physicMaterial;
                MeshBender mb = go.GetComponent<MeshBender>();
                mb.Source = SourceMesh.Build(mesh)
                    .Translate(translation)
                    .Rotate(Quaternion.Euler(rotation))
                    .Scale(scale);
                mb.SetInterval(spline, 0);
                mb.Mode = mode;
                mb.ComputeIfNeeded();
                used.Add(go);

            }

            // finally, we destroy the unused objects
            foreach (var go in generated.transform
                .Cast<Transform>()
                .Select(child => child.gameObject).Except(used)) {
                UOUtility.Destroy(go);
            }
        }


    }
}
