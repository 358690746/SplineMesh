using UnityEngine;
using UnityEditor;
using System;
using System.Collections.Generic;

namespace SplineMesh {
    /// <summary>
    /// A component that create a deformed mesh from a given one, according to a cubic Bézier curve and other parameters.
    /// The mesh will always be bended along the X axis. Extreme X coordinates of source mesh verticies will be used as a bounding to the deformed mesh.
    /// The resulting mesh is stored in a MeshFilter component and automaticaly updated each time the cubic Bézier curve control points are changed.
    /// </summary>
    [DisallowMultipleComponent]
    [RequireComponent(typeof(MeshFilter))]
    [ExecuteInEditMode]
    public class MeshBender : MonoBehaviour {
        private readonly List<Vertex> vertices = new List<Vertex>();
        private bool isDirty = false;
        private Mesh result;

        private Mesh source;
        /// <summary>
        /// The source mesh to bend.
        /// </summary>
        public Mesh Source {
            get { return source; }
            set {
                if (value == source) return;
                isDirty = true;
                source = value;
                vertices.Clear();
                int i = 0;
                foreach (Vector3 vert in source.vertices) {
                    Vertex v = new Vertex {
                        v = vert,
                        n = source.normals[i++]
                    };
                    vertices.Add(v);
                }

                result.hideFlags = source.hideFlags;
                result.indexFormat = source.indexFormat;
                result.vertices = source.vertices.ToArray();
                result.triangles = source.triangles.ToArray();

                result.uv = source.uv.ToArray();
                result.uv2 = source.uv2.ToArray();
                result.uv3 = source.uv3.ToArray();
                result.uv4 = source.uv4.ToArray();
                result.uv5 = source.uv5.ToArray();
                result.uv6 = source.uv6.ToArray();
                result.uv7 = source.uv7.ToArray();
                result.uv8 = source.uv8.ToArray();
                result.tangents = source.tangents.ToArray();
            }
        }

        private CubicBezierCurve curve;
        /// <summary>
        /// The cubic Bézier curve to use to bend the source mesh. The curve is observed and the mesh is bended again each time it changes.
        /// </summary>
        public CubicBezierCurve Curve {
            get { return curve; }
            set {
                if (value == curve) return;
                if(value == null) throw new ArgumentNullException(nameof(value));
                isDirty = true;
                if (curve != null) {
                    curve.Changed.RemoveListener(Compute);
                }
                curve = value;
                curve.Changed.AddListener(Compute);
            }
        }

        private Vector3 translation;
        /// <summary>
        /// The offset to apply to the source mesh before bending it.
        /// </summary>
        public Vector3 Translation {
            get { return translation; }
            set {
                if (value == translation) return;
                isDirty = true;
                translation = value;
            }
        }

        private Quaternion rotation;
        /// <summary>
        /// The rotation to apply to the source mesh before bending it.
        /// Because source mesh will always be bended along the X axis but may be oriented differently.
        /// </summary>
        public Quaternion Rotation {
            get { return rotation; }
            set {
                if (value == rotation) return;
                isDirty = true;
                rotation = value;
            }
        }

        private Vector3 scale;
        /// <summary>
        /// The scale to apply to the source mesh before bending it.
        /// Scale on X axis is internaly limited to -1;1 to restrain the mesh inside the curve bounds.
        /// </summary>
        public Vector3 Scale {
            get { return scale; }
            set {
                if (value == scale) return;
                isDirty = true;
                scale = value;
                scale.x = Mathf.Clamp(scale.x, -1, 1);
            }
        }
        private void OnEnable() {
            if(GetComponent<MeshFilter>().sharedMesh != null) {
                result = GetComponent<MeshFilter>().sharedMesh;
            } else {
                GetComponent<MeshFilter>().sharedMesh = result = new Mesh();
                result.name = "Generated by " + GetType().Name;
            }
        }

        private void Compute() {
            if (source == null)
                return;
            int nbVert = source.vertices.Length;
            // find the bounds along x
            float minX = float.MaxValue;
            float maxX = float.MinValue;
            foreach (Vertex vert in vertices) {
                Vector3 p = vert.v;
                if (rotation != Quaternion.identity) {
                    p = rotation * p;
                }
                if (translation != Vector3.zero) {
                    p += translation;
                }
                maxX = Math.Max(maxX, p.x);
                minX = Math.Min(minX, p.x);
            }
            float length = Math.Abs(maxX - minX);

            List<Vector3> deformedVerts = new List<Vector3>(nbVert);
            List<Vector3> deformedNormals = new List<Vector3>(nbVert);
            // for each mesh vertex, we found its projection on the curve
            foreach (Vertex vert in vertices) {
                Vector3 p = vert.v;
                Vector3 n = vert.n;
                //  application of rotation
                if (sourceRotation != Quaternion.identity) {
                    p = sourceRotation * p;
                    n = sourceRotation * n;
                }
                if (sourceTranslation != Vector3.zero) {
                    p += sourceTranslation;
                }
                float distanceRate = Math.Abs(p.x - minX) / length;

                Vector3 curvePoint = curve.GetLocationAtDistance(curve.Length * distanceRate);
                Vector3 curveTangent = curve.GetTangentAtDistance(curve.Length * distanceRate);
                float roll = curve.GetRoll(distanceRate);
                var scale = curve.GetScale(distanceRate);

                Quaternion q = curve.GetRotationAtDistance(curve.Length * distanceRate) * Quaternion.Euler(0, -90, 0);

                // application of scale (todo : we need the interpolation based on the distance, not time)
                p = Vector3.Scale(p, new Vector3(0, scale.y, scale.x));

                // application of roll (todo : we need the interpolation based on the distance, not time)
                p = Quaternion.AngleAxis(roll, Vector3.right) * p;
                n = Quaternion.AngleAxis(roll, Vector3.right) * n;

                // reset X value of p
                p = new Vector3(0, p.y, p.z);

                deformedVerts.Add(q * p + curvePoint);
                deformedNormals.Add(q * n);
            }

            result.vertices = deformedVerts.ToArray();
            result.normals = deformedNormals.ToArray();
            result.uv = source.uv;
            result.triangles = source.triangles;
            GetComponent<MeshFilter>().mesh = result;
        }

        private struct Vertex {
            public Vector3 v;
            public Vector3 n;
        }

        private void OnDestroy() {
            curve.Changed.RemoveListener(() => Compute());
        }
    }
}